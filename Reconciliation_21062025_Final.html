<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Purchase vs GSTR-2B Reconciliation</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- ExcelJS for Excel export/import -->
    <script src="https://cdn.jsdelivr.net/npm/exceljs@4.4.0/dist/exceljs.min.js"></script>
    <!-- FileSaver for download -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <style>
        body {
		  font-family: "Bookman Old Style", serif;
		  margin: 0;
		  padding: 0;
		  background: linear-gradient(120deg, #e0eafc 0%, #cfdef3 100%);
		}
		.container {
		  max-width: 1300px;
		  margin: 38px auto;
		  background: #fff;
		  padding: 38px 38px 40px 38px;
		  box-shadow: 0 5px 24px rgba(0, 0, 0, 0.12);
		  border-radius: 18px;
		}
		h1 {
		  text-align: center;
		  font-size: 2.6em;
		  font-weight: bold;
		  margin-bottom: 22px;
		  color: #08509c;
		  letter-spacing: 1.2px;
		}
		.section {
		  margin-bottom: 32px;
		}
		label {
		  display: block;
		  font-weight: bold;
		  margin-top: 12px;
		  margin-bottom: 4px;
		  color: #174c75;
		  font-size: 1.1em;
		  letter-spacing: 0.5px;
		}
		input,
		select {
		  padding: 8px 12px;
		  width: 98%;
		  border-radius: 5px;
		  border: 1px solid #bfc7d1;
		  font-size: 1.06em;
		  font-family: "Bookman Old Style", serif;
		  background: #fafdff;
		  transition: border 0.2s;
		}
		input:focus,
		select:focus {
		  border: 1.5px solid #0a6ebd;
		  outline: none;
		}
		.row-flex {
		  display: flex;
		  flex-wrap: wrap;
		  gap: 28px;
		}
		.col {
		  flex: 1 1 270px;
		  min-width: 250px;
		}
		.button {
		  background: linear-gradient(90deg, #0a6ebd 60%, #198754 100%);
		  color: #fff;
		  padding: 12px 34px;
		  font-size: 1.13em;
		  border: none;
		  border-radius: 6px;
		  font-family: "Bookman Old Style", serif;
		  cursor: pointer;
		  font-weight: bold;
		  margin-top: 18px;
		  margin-right: 14px;
		  letter-spacing: 0.5px;
		  box-shadow: 0 2px 7px rgba(10, 110, 189, 0.1);
		  transition: background 0.15s;
		}
		.button:disabled {
		  background: #ccc !important;
		  cursor: not-allowed;
		  color: #888;
		}
		.tabs {
		  margin-top: 36px;
		  border-bottom: 2.5px solid #d0d0d0;
		  display: flex;
		  gap: 14px;
		}
		.tab {
		  padding: 13px 28px;
		  cursor: pointer;
		  background: #f3f3f3;
		  border-top-left-radius: 10px;
		  border-top-right-radius: 10px;
		  font-weight: bold;
		  font-family: "Bookman Old Style", serif;
		  border: 1.5px solid #d0d0d0;
		  border-bottom: none;
		  color: #1457a6;
		  font-size: 1.08em;
		}
		.tab.active {
		  background: #fff;
		  border-bottom: 2.5px solid #fff;
		  color: #198754;
		  box-shadow: 0 -2px 10px 0 rgba(10, 110, 189, 0.03);
		}
		.tab-content {
		  display: none;
		  margin-top: 0;
		  background: #fff;
		  border: 1.5px solid #d0d0d0;
		  border-top: none;
		  border-bottom-left-radius: 10px;
		  border-bottom-right-radius: 10px;
		  padding: 28px 16px 32px 16px;
		  min-height: 280px;
		  overflow-x: auto;
		}
		.tab-content.active {
		  display: block;
		}
		table {
		  border-collapse: collapse;
		  width: 100%;
		  font-size: 1.03em;
		  margin-top: 6px;
		}
		th,
		td {
		  padding: 10px 7px;
		  border: 1.5px solid #b5cee7;
		  text-align: right;
		  font-family: "Bookman Old Style", serif;
		  background: #fcfcff;
		}
		th {
		  background: linear-gradient(90deg, #e7efff 70%, #def1fd 100%);
		  font-weight: bold;
		  text-align: center;
		  white-space: pre-line;
		  word-break: break-word;
		  font-size: 1.08em;
		  color: #0a6ebd;
		  border-bottom: 2.4px solid #b5cee7;
		}
		td.text,
		th.text {
		  text-align: left !important;
		}
		.red-bold {
		  color: #d0001c !important;
		  font-weight: bold !important;
		}
		.right {
		  text-align: right !important;
		}
		.wrap {
		  white-space: pre-line;
		  word-break: break-word;
		}
		.download-link {
		  color: #0a6ebd;
		  font-weight: bold;
		  text-decoration: underline;
		  margin-right: 12px;
		  cursor: pointer;
		  font-size: 1.08em;
		}
		.download-link:hover {
		  color: #198754;
		  text-decoration: underline wavy;
		}
		.note {
		  background: #f6f6d5;
		  border-left: 5px solid #ffe066;
		  padding: 10px 22px;
		  margin-top: 13px;
		  margin-bottom: 20px;
		  font-size: 1.08em;
		  color: #6f5e12;
		}
		.footer {
		  margin-top: 50px;
		  text-align: center;
		  font-size: 1.09em;
		  color: #5d5d5d;
		  background: none;
		}
		@media (max-width: 900px) {
		  .container {
			padding: 10px;
		  }
		  .row-flex {
			flex-direction: column;
			gap: 0;
		  }
		  h1 {
			font-size: 2em;
		  }
		  .tab {
			font-size: 1em;
			padding: 8px 10px;
		  }
		}
    </style>
</head>
<body>
<div class="container">
    <h1>Purchase vs GSTR-2B Reconciliation</h1>
    <div class="section">
        <div class="row-flex">
            <div class="col">
                <label for="taxpayerName">Name of Taxpayer</label>
                <input id="taxpayerName" type="text" placeholder="Enter taxpayer name">
            </div>
            <div class="col">
                <label for="gstin">GSTIN</label>
                <input id="gstin" type="text" placeholder="Enter GSTIN" maxlength="15">
            </div>
        </div>
        <div class="row-flex">
            <div class="col">
                <label for="periodFrom">Period From (Month-Year)</label>
                <input id="periodFrom" type="month">
            </div>
            <div class="col">
                <label for="periodTo">Period To (Month-Year)</label>
                <input id="periodTo" type="month">
            </div>
            <div class="col">
                <label for="rounding">Rounding Off</label>
                <select id="rounding">
                    <option value="0.00">0.00</option>
                    <option value="1.00" selected>1.00</option>
                    <option value="2.00">2.00</option>
                    <option value="5.00">5.00</option>
                    <option value="10.00">10.00</option>
                </select>
            </div>
        </div>
    </div>
    <div class="section">
        <label>Download Data Templates (Excel)</label>
        <span class="download-link" onclick="downloadTemplates()">Download Templates</span>
        <div class="note">
            <b>Instructions:</b>
            <ul>
                <li>Download the template and fill your "Books" and "Portal" (GSTR-2B) data as per sample.</li>
                <li>Import the filled Excel below. <b>Data must be on separate sheets:</b> "Books" for purchases, "Portal" for GSTR-2B.</li>
            </ul>
        </div>
        <div class="row-flex">
            <div class="col">
                <label for="booksFile">Import Purchase Details from Books (Excel)</label>
                <input type="file" accept=".xls,.xlsx" id="booksFile">
            </div>
            <div class="col">
                <label for="portalFile">Import GSTR-2B Details (Excel)</label>
                <input type="file" accept=".xls,.xlsx" id="portalFile">
            </div>
        </div>
        <div class="note" style="margin-top: 8px;">
            <b>Alternatively:</b> You may upload a single Excel file with both sheets ("Books" and "Portal").
        </div>
    </div>
    <div class="section">
        <button class="button" id="reconcileBtn" onclick="reconcile()" disabled>Reconcile</button>
        <button class="button" id="downloadBtn" onclick="downloadOutput()" style="background:#198754;display:none">Download Reconciliation Excel</button>
    </div>
    <div id="tabsContainer" style="display:none">
        <div class="tabs" id="tabs"></div>
        <div id="tabContents"></div>
    </div>
    <div class="footer">
        <b>How to use:</b> Enter details & period, download and fill template, import Excel files, click "Reconcile", view results in tabs, download the professionally formatted Excel output.<br>
        <span style="font-size:0.96em;">Developed for GST Reconciliation. All calculations & formatting as per your specifications.</span>
    </div>
</div>
<script>
// --- Helper functions (formatting) ---
function formatIndianNumber(num) {
    if (isNaN(num) || num === null || num === "") return "";
    num = Number(num);
    let [int, dec] = num.toFixed(2).split(".");
    let lastThree = int.substring(int.length - 3);
    let otherNumbers = int.substring(0, int.length - 3);
    if (otherNumbers !== '')
        lastThree = ',' + lastThree;
    let res = otherNumbers.replace(/\B(?=(\d{2})+(?!\d))/g, ",") + lastThree;
    return dec ? res + "." + dec : res;
}
function formatDate(dt) {
    if (!dt) return "";
    const monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    if (typeof dt === "number") {
        let utc_days = Math.floor(dt - 25569);
        let utc_value = utc_days * 86400;
        let date_info = new Date(utc_value * 1000);
        let day = String(date_info.getDate()).padStart(2, "0");
        let mon = monthNames[date_info.getMonth()];
        let yr = date_info.getFullYear();
        return `${day}-${mon}-${yr}`;
    }
    if (typeof dt === "string") {
        let s = dt.trim();
        let m = s.match(/^(\d{1,2})[\/\-.](\d{1,2})[\/\-.](\d{4})$/);
        if (m) {
            let day = m[1].padStart(2, "0");
            let monIdx = parseInt(m[2], 10) - 1;
            let mon = monthNames[monIdx];
            let yr = m[3];
            return `${day}-${mon}-${yr}`;
        }
        m = s.match(/^(\d{4})[\/\-.](\d{1,2})[\/\-.](\d{1,2})$/);
        if (m) {
            let day = m[3].padStart(2, "0");
            let monIdx = parseInt(m[2], 10) - 1;
            let mon = monthNames[monIdx];
            let yr = m[1];
            return `${day}-${mon}-${yr}`;
        }
        let d = new Date(s);
        if (!isNaN(d)) {
            let day = String(d.getDate()).padStart(2, "0");
            let mon = monthNames[d.getMonth()];
            let yr = d.getFullYear();
            return `${day}-${mon}-${yr}`;
        }
    }
    return "";
}
function excelDateToJSDate(serial) {
    const monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    let utc_days  = Math.floor(serial - 25569);
    let utc_value = utc_days * 86400;
    let date_info = new Date(utc_value * 1000);
    let day = String(date_info.getDate()).padStart(2, "0");
    let mon = monthNames[date_info.getMonth()];
    let yr = date_info.getFullYear();
    return `${day}-${mon}-${yr}`;
}

// Helper: Compare two floats up to rounding
function floatEqual(a, b, round) {
    return Math.abs(Number(a) - Number(b)) <= round;
}
// Helper: Convert string to upper and remove spaces
function parseDate(val) {
    if (typeof val === 'number') return excelDateToJSDate(val);
    if (/^\d{4}-\d{2}-\d{2}/.test(val)) return formatDate(val);
    if (/^\d{2}\/\d{2}\/\d{4}/.test(val)) return val;
    return val;
}
function parseNumber(val) {
    if (val === "" || val === null || val === undefined) return 0;
    return Number(String(val).replace(/,/g, "")) || 0;
}
function normStr(s) {
    return String(s || "").toUpperCase().replace(/\s+/g, '');
}

// --- ExcelJS-based file import ---
// Reads Excel file and returns array of objects for a given sheetName
async function readExcelFile(file, sheetName) {
    const workbook = new ExcelJS.Workbook();
    await workbook.xlsx.load(await file.arrayBuffer());
    const ws = workbook.getWorksheet(sheetName) || workbook.worksheets[0];
    if (!ws) return [];
    const headers = [];
    ws.getRow(1).eachCell((cell, colNumber) => {
        headers.push(cell.text.trim());
    });
    const data = [];
    ws.eachRow((row, rowNumber) => {
        if (rowNumber === 1) return;
        const obj = {};
        headers.forEach((h, idx) => {
            obj[h] = row.getCell(idx + 1).text;
        });
        data.push(obj);
    });
    return data;
}

// --- ExcelJS-based template download ---
async function downloadTemplates() {
    let booksHeaders = [
        "Date","Name of Supplier","GSTIN","Vch_Type","Vch_No.","Invoice_No.","Invoice_Date",
        "Taxable_Amount","IGST","CGST","SGST","CESS","Total_Tax_Amount"
    ];
    let booksSample = [
        ["01/05/2024","ABC Pvt Ltd","22AAAAA0000A1Z5","Purchase","101","INV123","01/05/2024",10000,500,250,250,0,1000]
    ];
    let portalHeaders = [
        "GSTIN","Trade_Name","Invoice_No.","Invoice_Type","Invoice_Date","Invoice_Value","Place_of_supply",
        "Supply_Attract_Reverse_Charge","Taxable_Amount","IGST","CGST","SGST","CESS",
        "GSTR-1/_IFF/_GSTR-5_Period","GSTR-1/_IFF/_GSTR-5_Filing_Date",
        "ITC_Availability","Reason","Applicable_%_of_Tax_Rate","Source","IRN","IRN_Date"
    ];
    let portalSample = [
        ["22AAAAA0000A1Z5","ABC Pvt Ltd","INV123","Regular","01/05/2024",11000,"Chhattisgarh","N",10000,500,250,250,0,"Apr-2024","10/05/2024","Available","",18,"Portal","",""]
    ];
    let wb = new ExcelJS.Workbook();
    let wsBooks = wb.addWorksheet("Books");
    wsBooks.addRow(booksHeaders);
    booksSample.forEach(row => wsBooks.addRow(row));
    let wsPortal = wb.addWorksheet("Portal");
    wsPortal.addRow(portalHeaders);
    portalSample.forEach(row => wsPortal.addRow(row));
    const buf = await wb.xlsx.writeBuffer();
    saveAs(new Blob([buf]), "GST_Reconciliation_Template.xlsx");
}

// --- File upload logic (ExcelJS, supports both single-file and two-file mode) ---
let booksData = [], portalData = [];
let excelLoaded = false;

// Helper to extract both sheets if present
async function extractSheetsFromFile(file) {
    const workbook = new ExcelJS.Workbook();
    await workbook.xlsx.load(await file.arrayBuffer());
    let foundBooks = null, foundPortal = null;
    workbook.eachSheet((ws, sheetId) => {
        if (ws.name.trim().toLowerCase() === "books") foundBooks = ws;
        if (ws.name.trim().toLowerCase() === "portal") foundPortal = ws;
    });
    // Fallback: if only one sheet, use as per input
    if (!foundBooks && workbook.getWorksheet(1)) foundBooks = workbook.getWorksheet(1);
    if (!foundPortal && workbook.getWorksheet(2)) foundPortal = workbook.getWorksheet(2);

    const parseSheet = (ws) => {
        if (!ws) return [];
        const headers = [];
        ws.getRow(1).eachCell((cell, colNumber) => {
            headers.push(cell.text.trim());
        });
        const data = [];
        ws.eachRow((row, rowNumber) => {
            if (rowNumber === 1) return;
            const obj = {};
            headers.forEach((h, idx) => { obj[h] = row.getCell(idx + 1).text; });
            data.push(obj);
        });
        return data;
    };

    return {
        books: foundBooks ? parseSheet(foundBooks) : [],
        portal: foundPortal ? parseSheet(foundPortal) : [],
    };
}

// Handle user uploading either file
async function handleFileUpload(e) {
    const file = e.target.files[0];
    if (!file) return;
    const {books, portal} = await extractSheetsFromFile(file);

    // Use data if available, but do not overwrite if one is already loaded from another input
    if (books.length) booksData = books;
    if (portal.length) portalData = portal;

    checkReadiness();
}

// Attach to both file inputs
document.getElementById('booksFile').addEventListener('change', handleFileUpload);
document.getElementById('portalFile').addEventListener('change', handleFileUpload);

// Readiness check
function checkReadiness() {
    excelLoaded = booksData.length > 0 && portalData.length > 0;
    document.getElementById('reconcileBtn').disabled = !excelLoaded;
    if (excelLoaded) alert("Both Books and Portal data loaded. Ready to Reconcile.");
}
// Set default periods to last month
function setDefaultPeriod() {
    let now = new Date();
    let y = now.getFullYear();
    let m = now.getMonth(); // last month
    if (m === 0) { y = y-1; m = 12; }
    else { m = m; }
    let mm = String(m).padStart(2,'0');
    document.getElementById('periodFrom').value = `${y}-${mm}`;
    document.getElementById('periodTo').value = `${y}-${mm}`;
}
setDefaultPeriod();

let tabOrder = [
    "Books","Portal",
    "FULLY_MATCHED","PARTIAL_MATCH_INVOICE","PARTIAL_MATCH_DATE",
    "RCM","MISMATCH","MISMATCH_DATE",
    "ONLY_BOOKS","ONLY_PORTAL"
];
let tabLabels = {
    "Books":"Books (Imported)",
    "Portal":"Portal-GSTR-2B (Imported)",
    "FULLY_MATCHED":"Fully Matched",
    "PARTIAL_MATCH_INVOICE":"Partial Match (Invoice)",
    "PARTIAL_MATCH_DATE":"Partial Match (Date)",
    "RCM":"RCM",
    "MISMATCH":"Mismatch",
    "MISMATCH_DATE":"Mismatch (Date)",
    "ONLY_BOOKS":"Only in Books",
    "ONLY_PORTAL":"Only in Portal"
};
let resultSheets = {};
let outputWorkbook = null;

// Reconcile Logic
function reconcile() {
    // Allow all fields to be empty except Excel data
    if (!excelLoaded) {
        alert("Please load both Books and Portal data to reconcile.");
        return;
    }
    let taxpayer = document.getElementById('taxpayerName').value.trim();
    let gstin = document.getElementById('gstin').value.trim().toUpperCase();
    let periodFrom = document.getElementById('periodFrom').value;
    let periodTo = document.getElementById('periodTo').value;
    let rounding = parseFloat(document.getElementById('rounding').value);

    let books = booksData.map(row => ({
        Date: formatDate(row["Date"]),
        Name_of_Supplier: row["Name of Supplier"]||row["Name_of_Supplier"]||"",
        GSTIN: (row["GSTIN"]||"").toUpperCase(),
        Vch_Type: row["Vch_Type"]||"",
        Vch_No: row["Vch_No."]||"",
        Invoice_No: String(row["Invoice_No."]||row["Invoice_No"]||"").toUpperCase(),
        Invoice_Date: formatDate(row["Invoice_Date"]||row["Invoice_Date."]),
        Taxable_Amount: parseNumber(row["Taxable_Amount"]),
        IGST: parseNumber(row["IGST"]),
        CGST: parseNumber(row["CGST"]),
        SGST: parseNumber(row["SGST"]),
        CESS: parseNumber(row["CESS"]),
        Total_Tax_Amount: parseNumber(row["Total_Tax_Amount"])
    }));

    let portal = portalData.map(row => ({
        GSTIN: (row["GSTIN"]||"").toUpperCase(),
        Trade_Name: row["Trade_Name"]||"",
        Invoice_No: String(row["Invoice_No."]||row["Invoice_No"]||"").toUpperCase(),
        Invoice_Type: row["Invoice_Type"]||"",
        Invoice_Date: formatDate(row["Invoice_Date"]||row["Invoice_Date."]),
        Invoice_Value: parseNumber(row["Invoice_Value"]),
        Place_of_supply: row["Place_of_supply"]||"",
        Supply_Attract_Reverse_Charge: (row["Supply_Attract_Reverse_Charge"]||"").toUpperCase(),
        Taxable_Amount: parseNumber(row["Taxable_Amount"]),
        IGST: parseNumber(row["IGST"]),
        CGST: parseNumber(row["CGST"]),
        SGST: parseNumber(row["SGST"]),
        CESS: parseNumber(row["CESS"]),
        Period: row["GSTR-1/_IFF/_GSTR-5_Period"]||"",
        Filing_Date: formatDate(row["GSTR-1/_IFF/_GSTR-5_Filing_Date"]),
        ITC_Availability: row["ITC_Availability"]||"",
        Reason: row["Reason"]||"",
        Applicable_Tax_Rate: row["Applicable_%_of_Tax_Rate"]||"",
        Source: row["Source"]||"",
        IRN: row["IRN"]||"",
        IRN_Date: formatDate(row["IRN_Date"]||"")
    }));

    let portalIndex = {}, portalUsed = new Array(portal.length).fill(false);
    let booksIndex = {}, booksUsed = new Array(books.length).fill(false);

    function key1(obj) { return normStr(obj.GSTIN)+"|"+normStr(obj.Invoice_No)+"|"+formatDate(obj.Invoice_Date); }
    function key2(obj) { return normStr(obj.GSTIN)+"|"+normStr(obj.Invoice_No); }
    function key3(obj) { return normStr(obj.GSTIN)+"|"+formatDate(obj.Invoice_Date); }

    portal.forEach((row, i) => {
        let k1 = key1(row), k2 = key2(row), k3 = key3(row);
        if (!portalIndex[k1]) portalIndex[k1] = [];
        portalIndex[k1].push(i);
        if (!portalIndex[k2]) portalIndex[k2] = [];
        portalIndex[k2].push(i);
        if (!portalIndex[k3]) portalIndex[k3] = [];
        portalIndex[k3].push(i);
    });
    books.forEach((row, i) => {
        let k1 = key1(row), k2 = key2(row), k3 = key3(row);
        if (!booksIndex[k1]) booksIndex[k1] = [];
        booksIndex[k1].push(i);
        if (!booksIndex[k2]) booksIndex[k2] = [];
        booksIndex[k2].push(i);
        if (!booksIndex[k3]) booksIndex[k3] = [];
        booksIndex[k3].push(i);
    });

    // 1. RCM
    let RCM = [];
    portal.forEach((row, i) => {
        let val = (row.Supply_Attract_Reverse_Charge||"").toUpperCase();
        if (val === "YES" || val === "Y") {
            RCM.push({
                GSTIN: row.GSTIN,
                Trade_Name: row.Trade_Name,
                Invoice_No: row.Invoice_No,
                Invoice_Type: row.Invoice_Type,
                Invoice_Date: row.Invoice_Date,
                Supply_Attract_Reverse_Charge: row.Supply_Attract_Reverse_Charge,
                Taxable_Amount: row.Taxable_Amount,
                IGST: row.IGST,
                CGST: row.CGST,
                SGST: row.SGST,
                CESS: row.CESS,
                Period: row.Period,
                Filing_Date: row.Filing_Date,
                Remarks: ""
            });
            portalUsed[i] = true;
        }
    });

    // 2. FULLY_MATCHED
    let FULLY_MATCHED = [];
    books.forEach((b, i) => {
        if (booksUsed[i]) return;
        let idxs = portalIndex[key1(b)] || [];
        let found = null, pj = -1;
        for (let j of idxs) {
            if (portalUsed[j]) continue;
            let p = portal[j];
            if (
                floatEqual(b.Taxable_Amount, p.Taxable_Amount, rounding) &&
                floatEqual(b.IGST, p.IGST, rounding) &&
                floatEqual(b.CGST, p.CGST, rounding) &&
                floatEqual(b.SGST, p.SGST, rounding) &&
                floatEqual(b.CESS, p.CESS, rounding)
            ) {
                found = p; pj = j; break;
            }
        }
        if (found) {
            FULLY_MATCHED.push({
                "Name of Supplier": found.Trade_Name,
                GSTIN: found.GSTIN,
                Invoice_No: found.Invoice_No,
                Invoice_Date: found.Invoice_Date,
                Taxable_Amount: b.Taxable_Amount,
                IGST: b.IGST,
                CGST: b.CGST,
                SGST: b.SGST,
                CESS: b.CESS,
                Total_Tax_Amount: b.Total_Tax_Amount,
                Period: found.Period,
                Filing_Date: found.Filing_Date,
                Remarks: ""
            });
            booksUsed[i] = true;
            portalUsed[pj] = true;
        }
    });

    // 3. MISMATCH
    let MISMATCH = [];
    books.forEach((b, i) => {
        if (booksUsed[i]) return;
        let idxs = portalIndex[key1(b)] || [];
        let found = null, pj = -1;
        for (let j of idxs) {
            if (portalUsed[j]) continue;
            let p = portal[j];
            if (
                !(
                    floatEqual(b.Taxable_Amount, p.Taxable_Amount, rounding) &&
                    floatEqual(b.IGST, p.IGST, rounding) &&
                    floatEqual(b.CGST, p.CGST, rounding) &&
                    floatEqual(b.SGST, p.SGST, rounding) &&
                    floatEqual(b.CESS, p.CESS, rounding)
                )
            ) {
                found = p; pj = j; break;
            }
        }
        if (found) {
            MISMATCH.push({
                "Name of Supplier": found.Trade_Name,
                GSTIN: found.GSTIN,
                Invoice_No: b.Invoice_No,
                Invoice_Date: b.Invoice_Date,
                Taxable_Amount_Books: b.Taxable_Amount,
                IGST_Books: b.IGST,
                CGST_Books: b.CGST,
                SGST_Books: b.SGST,
                CESS_Books: b.CESS,
                Total_Tax_Amount_Books: b.Total_Tax_Amount,
                Taxable_Amount_Portal: found.Taxable_Amount,
                IGST_Portal: found.IGST,
                CGST_Portal: found.CGST,
                SGST_Portal: found.SGST,
                CESS_Portal: found.CESS,
                Total_Tax_Amount_Portal: found.IGST + found.CGST + found.SGST + found.CESS,
                Period: found.Period,
                Filing_Date: found.Filing_Date,
                Difference_Taxable_Amount: b.Taxable_Amount - found.Taxable_Amount,
                Difference_IGST: b.IGST - found.IGST,
                Difference_CGST: b.CGST - found.CGST,
                Difference_SGST: b.SGST - found.SGST,
                Difference_CESS: b.CESS - found.CESS,
                Difference_Total_Tax_Amount: b.Total_Tax_Amount - (found.IGST + found.CGST + found.SGST + found.CESS),
                Remarks: ""
            });
            booksUsed[i] = true;
            portalUsed[pj] = true;
        }
    });

    // 4. PARTIAL_MATCH_INVOICE
    let PARTIAL_MATCH_INVOICE = [];
    books.forEach((b, i) => {
        if (booksUsed[i]) return;
        let idxs = portalIndex[key2(b)] || [];
        let found = null, pj = -1;
        for (let j of idxs) {
            if (portalUsed[j]) continue;
            let p = portal[j];
            if (
                floatEqual(b.Taxable_Amount, p.Taxable_Amount, rounding) &&
                floatEqual(b.IGST, p.IGST, rounding) &&
                floatEqual(b.CGST, p.CGST, rounding) &&
                floatEqual(b.SGST, p.SGST, rounding) &&
                floatEqual(b.CESS, p.CESS, rounding)
            ) {
                found = p; pj = j; break;
            }
        }
        if (found) {
            PARTIAL_MATCH_INVOICE.push({
                "Name of Supplier": found.Trade_Name,
                GSTIN: found.GSTIN,
                Invoice_No: b.Invoice_No,
                Invoice_Date_Books: b.Invoice_Date,
                Taxable_Amount: b.Taxable_Amount,
                IGST: b.IGST,
                CGST: b.CGST,
                SGST: b.SGST,
                CESS: b.CESS,
                Total_Tax_Amount: b.Total_Tax_Amount,
                Invoice_Date_Portal: found.Invoice_Date,
                Period: found.Period,
                Filing_Date: found.Filing_Date,
                Remarks: ""
            });
            booksUsed[i] = true;
            portalUsed[pj] = true;
        }
    });

    // 5. MISMATCH_DATE
    let MISMATCH_DATE = [];
    books.forEach((b, i) => {
        if (booksUsed[i]) return;
        let idxs = portalIndex[key2(b)] || [];
        let found = null, pj = -1;
        for (let j of idxs) {
            if (portalUsed[j]) continue;
            let p = portal[j];
            if (
                !(
                    floatEqual(b.Taxable_Amount, p.Taxable_Amount, rounding) &&
                    floatEqual(b.IGST, p.IGST, rounding) &&
                    floatEqual(b.CGST, p.CGST, rounding) &&
                    floatEqual(b.SGST, p.SGST, rounding) &&
                    floatEqual(b.CESS, p.CESS, rounding)
                )
            ) {
                found = p; pj = j; break;
            }
        }
        if (found) {
            MISMATCH_DATE.push({
                "Name of Supplier": found.Trade_Name,
                GSTIN: found.GSTIN,
                Invoice_No_Books: b.Invoice_No,
                Invoice_Date_Books: b.Invoice_Date,
                Taxable_Amount_Books: b.Taxable_Amount,
                IGST_Books: b.IGST,
                CGST_Books: b.CGST,
                SGST_Books: b.SGST,
                CESS_Books: b.CESS,
                Total_Tax_Amount_Books: b.Total_Tax_Amount,
                Invoice_No_Portal: found.Invoice_No,
                Invoice_Date_Portal: found.Invoice_Date,
                Taxable_Amount_Portal: found.Taxable_Amount,
                IGST_Portal: found.IGST,
                CGST_Portal: found.CGST,
                SGST_Portal: found.SGST,
                CESS_Portal: found.CESS,
                Total_Tax_Amount_Portal: found.IGST + found.CGST + found.SGST + found.CESS,
                Period: found.Period,
                Filing_Date: found.Filing_Date,
                Difference_Taxable_Amount: b.Taxable_Amount - found.Taxable_Amount,
                Difference_IGST: b.IGST - found.IGST,
                Difference_CGST: b.CGST - found.CGST,
                Difference_SGST: b.SGST - found.SGST,
                Difference_CESS: b.CESS - found.CESS,
                Difference_Total_Tax_Amount: b.Total_Tax_Amount - (found.IGST + found.CGST + found.SGST + found.CESS),
                Remarks: ""
            });
            booksUsed[i] = true;
            portalUsed[pj] = true;
        }
    });

    // 6. PARTIAL_MATCH_DATE
    let PARTIAL_MATCH_DATE = [];
    books.forEach((b, i) => {
        if (booksUsed[i]) return;
        let idxs = portalIndex[key3(b)] || [];
        let found = null, pj = -1;
        for (let j of idxs) {
            if (portalUsed[j]) continue;
            let p = portal[j];
            if (
                floatEqual(b.Taxable_Amount, p.Taxable_Amount, rounding) &&
                floatEqual(b.IGST, p.IGST, rounding) &&
                floatEqual(b.CGST, p.CGST, rounding) &&
                floatEqual(b.SGST, p.SGST, rounding) &&
                floatEqual(b.CESS, p.CESS, rounding)
            ) {
                found = p; pj = j; break;
            }
        }
        if (found) {
            PARTIAL_MATCH_DATE.push({
                "Name of Supplier": found.Trade_Name,
                GSTIN: found.GSTIN,
                Invoice_No_Books: b.Invoice_No,
                Invoice_Date: b.Invoice_Date,
                Taxable_Amount: b.Taxable_Amount,
                IGST: b.IGST,
                CGST: b.CGST,
                SGST: b.SGST,
                CESS: b.CESS,
                Total_Tax_Amount: b.Total_Tax_Amount,
                Invoice_No_Portal: found.Invoice_No,
                Period: found.Period,
                Filing_Date: found.Filing_Date,
                Remarks: ""
            });
            booksUsed[i] = true;
            portalUsed[pj] = true;
        }
    });

    // 7. ONLY_BOOKS
    let ONLY_BOOKS = [];
    books.forEach((b, i) => {
        if (!booksUsed[i]) {
            ONLY_BOOKS.push({
                "Name of Supplier": b.Name_of_Supplier,
                GSTIN: b.GSTIN,
                Invoice_No: b.Invoice_No,
                Invoice_Date: b.Invoice_Date,
                Taxable_Amount: b.Taxable_Amount,
                IGST: b.IGST,
                CGST: b.CGST,
                SGST: b.SGST,
                CESS: b.CESS,
                Total_Tax_Amount: b.Total_Tax_Amount,
                Remarks: ""
            });
        }
    });

    // 8. ONLY_PORTAL
    let ONLY_PORTAL = [];
    portal.forEach((p, j) => {
        if (!portalUsed[j]) {
            ONLY_PORTAL.push({
                GSTIN: p.GSTIN,
                Trade_Name: p.Trade_Name,
                Invoice_No: p.Invoice_No,
                Invoice_Type: p.Invoice_Type,
                Invoice_Date: p.Invoice_Date,
                Taxable_Amount: p.Taxable_Amount,
                IGST: p.IGST,
                CGST: p.CGST,
                SGST: p.SGST,
                CESS: p.CESS,
                Period: p.Period,
                Filing_Date: p.Filing_Date,
                Remarks: ""
            });
        }
    });

    resultSheets = {
        Books: books,
        Portal: portal,
        FULLY_MATCHED,
        PARTIAL_MATCH_INVOICE,
        PARTIAL_MATCH_DATE,
        RCM,
        MISMATCH,
        MISMATCH_DATE,
        ONLY_BOOKS,
        ONLY_PORTAL
    };

    showTabs();
    document.getElementById('downloadBtn').style.display = "inline-block";
    document.getElementById('downloadBtn').disabled = false;
    outputWorkbook = null;
    alert("Reconciliation Completed! View results in tabs below.");
}

// Tab rendering
function showTabs() {
    let tabsDiv = document.getElementById('tabs');
    let tabContentsDiv = document.getElementById('tabContents');
    let tabsHtml = '';
    let tabContentsHtml = '';
    let firstActive = '';
    for (let tab of tabOrder) {
        if (!resultSheets[tab]) continue;
        if (!firstActive) firstActive = tab;
        tabsHtml += `<div class="tab${tab===firstActive?' active':''}" data-tabname="${tab}" onclick="activateTab('${tab}')">${tabLabels[tab]||tab}</div>`;
        let tableHtml = renderTable(tab, resultSheets[tab]);
        tabContentsHtml += `<div class="tab-content${tab===firstActive?' active':''}" id="tab-content-${tab}">${tableHtml}</div>`;
    }
    tabsDiv.innerHTML = tabsHtml;
    tabContentsDiv.innerHTML = tabContentsHtml;
    document.getElementById('tabsContainer').style.display = "block";
}
function activateTab(tab) {
    document.querySelectorAll('.tab').forEach(el=>el.classList.remove('active'));
    document.querySelectorAll('.tab-content').forEach(el=>el.classList.remove('active'));
    document.querySelector(`.tab[data-tabname="${tab}"]`).classList.add('active');
    document.getElementById('tab-content-'+tab).classList.add('active');
}

// Table rendering (with formatting as per requirements)
function renderTable(sheetName, rows) {
    if (!rows || rows.length === 0) return "<div>No records found.</div>";
    let cols = Object.keys(rows[0]);
    // Special formatting columns
    let rightCols = cols.filter(c =>
        !/(Date|Invoice_No|Invoice_Type|Trade_Name|Name|Remarks)/i.test(c)
    );
    // Identify mismatches in relevant sheets
    let highlightCols = [];
    if (sheetName === "MISMATCH" || sheetName === "MISMATCH_DATE" ||
        sheetName === "PARTIAL_MATCH_INVOICE" || sheetName === "PARTIAL_MATCH_DATE") {
        highlightCols = cols.filter(c =>
            /Difference_|Invoice_Date1|Invoice_No1|Invoice_Date|Invoice_No/.test(c)
        );
    }
    let redCols = [];
    if (sheetName === "PARTIAL_MATCH_INVOICE") redCols = ["Invoice_Date_Books","Invoice_Date_Portal"];
    if (sheetName === "PARTIAL_MATCH_DATE") redCols = ["Invoice_No_Books","Invoice_No_Portal"];
    if (sheetName === "MISMATCH" || sheetName === "MISMATCH_DATE") {
        redCols = cols.filter(c=>/^Difference_/.test(c) || /Invoice_No_Books|Invoice_Date_Books|Invoice_No_Portal|Invoice_Date_Portal/.test(c));
    }
    let ths = cols.map(c=>`<th class="wrap${rightCols.includes(c)?' right':' text'}">${c.replace(/_/g," ")}</th>`).join("");
    let tdsAll = "";
    let totals = {};
    for (let i=0; i<rows.length; i++) {
        let row = rows[i];
        let tr = "";
        for (let c of cols) {
            let val = row[c];
            let style = "";
            let cellClass = "";
            if (rightCols.includes(c) && typeof val === 'number') {
                val = formatIndianNumber(val);
                style = 'style="text-align:right"';
                totals[c] = (totals[c]||0) + parseNumber(row[c]);
            }
            if (/(Date)/i.test(c) && val && val.toString().length > 0) {
                val = formatDate(val);
                style = 'style="text-align:right"';
            }
            if (redCols.includes(c)) cellClass += ' red-bold';
            tr += `<td class="${cellClass}${rightCols.includes(c)?' right':' text'}" ${style}>${val||""}</td>`;
        }
        tdsAll += `<tr>${tr}</tr>`;
    }
    let totalRow = "";
    let totalCols = ["Taxable_Amount","IGST","CGST","SGST","CESS","Total_Tax_Amount","Taxable_Amount1","IGST1","CGST1","SGST1","CESS1","Total_Tax_Amount1"];
    let anyTotal = cols.some(c=>totalCols.includes(c));
    if (anyTotal) {
        let tr = "";
        for (let c of cols) {
            if (totalCols.includes(c)) tr += `<td class="right" style="font-weight:bold">${formatIndianNumber(totals[c]||0)}</td>`;
            else tr += "<td></td>";
        }
        totalRow = `<tr style="background:#f9f9be;font-weight:bold"><td colspan="${cols.length}" style="text-align:left;padding-left:9px;font-style:italic;font-size:0.96em"><b>Totals:</b></td></tr><tr>${tr}</tr>`;
    }
    return `<table><thead><tr>${ths}</tr></thead><tbody>${tdsAll}${totalRow}</tbody></table>`;
}
// --- ExcelJS-based downloadOutput function ---
async function downloadOutput() {
    if (!resultSheets) return;
    let taxpayer = document.getElementById('taxpayerName').value.trim().toUpperCase();
    let gstin = document.getElementById('gstin').value.trim().toUpperCase();
    let periodFrom = document.getElementById('periodFrom').value;
    let periodTo = document.getElementById('periodTo').value;
    let pf = periodFrom ? periodFrom.split('-') : [];
    let pt = periodTo ? periodTo.split('-') : [];
    let pfStr = pf.length ? (new Date(periodFrom + "-01")).toLocaleString("en-IN", { month: "short", year: "numeric" }).replace(" ", "-") : "";
    let ptStr = pt.length ? (new Date(periodTo + "-01")).toLocaleString("en-IN", { month: "short", year: "numeric" }).replace(" ", "-") : "";
    let periodLine = `Period: ${pfStr} to ${ptStr}`;

    // Fixed width mapping (header as per Excel display, not source keys)
    const fixedWidths = {
        "Date": 16,
        "Name of Supplier": 35,
        "G S T I N": 26,
        "Vch Type": 18,
        "Vch No": 25,
        "Invoice No": 25,
        "Invoice Date": 16,
        "Taxable Amount": 18,
        "I G S T": 18,
        "C G S T": 18,
        "S G S T": 18,
        "C E S S": 18,
        "Total Tax Amount": 18,
        "Remarks": 35,
        "Trade Name": 35,
        "Invoice Type": 12,
        "Invoice Value": 18,
        "Place of supply": 12,
        "Supply Attract Reverse Charge": 16,
        "Period": 12,
        "Filing Date": 16,
        "I T C Availability": 12,
        "Reason": 12,
        "Applicable Tax Rate": 12,
        "Source": 12,
        "I R N": 12,
        "I R N Date": 16,
        "Invoice Date Books": 16,
        "Invoice Date Portal": 16,
        "Invoice No Books": 25,
        "Invoice No Portal": 25,
        "Taxable Amount Books": 18,
        "I G S T Books": 18,
        "C G S T Books": 18,
        "S G S T Books": 18,
        "C E S S Books": 18,
        "Total Tax Amount Books": 18,
        "Taxable Amount Portal": 18,
        "I G S T Portal": 18,
        "C G S T Portal": 18,
        "S G S T Portal": 18,
        "C E S S Portal": 18,
        "Total Tax Amount Portal": 18,
        "Difference Taxable Amount": 18,
        "Difference I G S T": 18,
        "Difference C G S T": 18,
        "Difference S G S T": 18,
        "Difference C E S S": 18,
        "Difference Total Tax Amount": 18
    };

    // Columns to be formatted in Indian Number Format
    const indianNumberCols = [
        "Taxable Amount",
        "I G S T",
        "C G S T",
        "S G S T",
        "C E S S",
        "Total Tax Amount",
        "Invoice Value",
        "Taxable Amount Books",
        "I G S T Books",
        "C G S T Books",
        "S G S T Books",
        "C E S S Books",
        "Total Tax Amount Books",
        "Taxable Amount Portal",
        "I G S T Portal",
        "C G S T Portal",
        "S G S T Portal",
        "C E S S Portal",
        "Total Tax Amount Portal",
        "Difference Taxable Amount",
        "Difference I G S T",
        "Difference C G S T",
        "Difference S G S T",
        "Difference C E S S",
        "Difference Total Tax Amount"
    ];

    // Utility: Indian number format (for ExcelJS, use numFmt, but also set value as number)
    function getIndianNumFmt() {
        return '#,##,##0.00';
    }

    // Utility: find normalized mapping for header names
    function normalizeHeader(header) {
        return header.replace(/\s+/g, "").replace(/_/g, "").toLowerCase();
    }

    let workbook = new ExcelJS.Workbook();
    workbook.creator = "GST Reconciliation Tool";
    workbook.created = new Date();

    for (let tab of tabOrder) {
        if (!resultSheets[tab] || resultSheets[tab].length === 0) continue;
        let sheet = workbook.addWorksheet(tab);
        let rows = resultSheets[tab];
        let cols = Object.keys(rows[0]);

        // Headings
        sheet.mergeCells(1, 1, 1, cols.length);
        sheet.getCell(1, 1).value = taxpayer;
        sheet.getCell(1, 1).font = { name: "Bookman Old Style", size: 22, bold: true, color: { argb: "FF08509c" } };
        sheet.getCell(1, 1).alignment = { vertical: "middle", horizontal: "center" };

        sheet.mergeCells(2, 1, 2, cols.length);
        sheet.getCell(2, 1).value = "GSTIN: " + gstin;
        sheet.getCell(2, 1).font = { name: "Bookman Old Style", size: 16, bold: true, color: { argb: "FF1457a6" } };
        sheet.getCell(2, 1).alignment = { vertical: "middle", horizontal: "center" };

        sheet.mergeCells(3, 1, 3, cols.length);
        sheet.getCell(3, 1).value = periodLine;
        sheet.getCell(3, 1).font = { name: "Bookman Old Style", size: 14, bold: true, color: { argb: "FF174c75" } };
        sheet.getCell(3, 1).alignment = { vertical: "middle", horizontal: "center" };
        sheet.addRow([]);

        // Table header (prettified, but keep mapping)
        let displayHeaders = cols.map(h =>
            h.replace(/_/g, ' ')
             .replace(/([A-Z])/g, ' $1')
             .replace(/\s+/g, ' ')
             .replace(/\bGst\b/i, 'GST')
             .replace(/\bIgst\b/i, 'I G S T')
             .replace(/\bCgst\b/i, 'C G S T')
             .replace(/\bSgst\b/i, 'S G S T')
             .replace(/\bCess\b/i, 'C E S S')
             .replace(/\bItc\b/i, 'I T C')
             .replace(/\bIrn\b/i, 'I R N')
             .trim()
        );
        let headerRow = sheet.addRow(displayHeaders);

        // Calculate required header row height (36 minimum, more if needed for wrap)
        let maxLines = 1;
        displayHeaders.forEach((header, i) => {
            // Estimate lines based on length and column width (since wrapText is on)
            let colWidth = fixedWidths[header] || 12;
            // Approximate: each 10 chars fits in width 12, so adjust for your font
            let lines = Math.ceil(header.length / Math.max(1, Math.floor(colWidth * 1.2)));
            if (lines > maxLines) maxLines = lines;
        });
        headerRow.height = Math.max(36, 18 * maxLines);

        headerRow.eachCell((cell) => {
            cell.font = { name: "Bookman Old Style", size: 12, bold: true, color: { argb: "FF08509c" } };
            cell.fill = { type: "pattern", pattern: "solid", fgColor: { argb: "FFE7EFFF" } };
            cell.border = { top: { style: "thin" }, left: { style: "thin" }, right: { style: "thin" }, bottom: { style: "thin" } };
            cell.alignment = { vertical: "middle", horizontal: "center", wrapText: true };
        });

        // Find special column indices for wrapText in data
        const nameSupplierColIdx = displayHeaders.findIndex(c => normalizeHeader(c) === "nameofsupplier");
        const tradeNameColIdx = displayHeaders.findIndex(c => normalizeHeader(c) === "tradename");

        // Data rows
        let totalCols = [
            "Taxable_Amount", "IGST", "CGST", "SGST", "CESS", "Total_Tax_Amount",
            "Taxable_Amount1", "IGST1", "CGST1", "SGST1", "CESS1", "Total_Tax_Amount1"
        ];
        let totals = {};
        let dataRowStartIndex = sheet.rowCount + 1;

        for (let r of rows) {
            let arr = [];
            for (let ix = 0; ix < cols.length; ix++) {
                let c = cols[ix];
                let headerName = displayHeaders[ix];
                let val = r[c];

                // Store numbers as numbers, and format in Excel as Indian format if in list
                if (typeof val === "number" && indianNumberCols.includes(headerName)) {
                    arr.push(val);
                } else if (/(Date)/i.test(headerName) && val) {
                    arr.push(formatDate(val));
                } else {
                    arr.push(val);
                }
                if (typeof val === "number" && totalCols.includes(c)) {
                    totals[c] = (totals[c] || 0) + parseNumber(val);
                }
            }
            let dataRow = sheet.addRow(arr);
            dataRow.height = 18;
            dataRow.eachCell((cell, colNumber) => {
                let colName = displayHeaders[colNumber - 1];
                // Alignment & number format
                if (typeof arr[colNumber - 1] === "number" && indianNumberCols.includes(colName)) {
                    cell.numFmt = getIndianNumFmt();
                    cell.alignment = { vertical: "middle", horizontal: "right", wrapText: false };
                } else if (/(Date)/i.test(colName)) {
                    cell.alignment = { vertical: "middle", horizontal: "right", wrapText: false };
                } else {
                    cell.alignment = { vertical: "middle", horizontal: "left", wrapText: false };
                }
                // Wrap text for Name of Supplier or Trade Name if string is long
                if (
                    (colNumber - 1 === nameSupplierColIdx || colNumber - 1 === tradeNameColIdx)
                    && typeof cell.value === "string"
                    && cell.value.length > 25
                ) {
                    cell.alignment = { ...cell.alignment, wrapText: true };
                }
                cell.font = { name: "Bookman Old Style", size: 11, color: { argb: "FF222222" } };
                cell.border = { top: { style: "thin" }, left: { style: "thin" }, right: { style: "thin" }, bottom: { style: "thin" } };
                // Highlight mismatches
                if ((tab === "MISMATCH" || tab === "MISMATCH_DATE" || tab === "PARTIAL_MATCH_INVOICE" || tab === "PARTIAL_MATCH_DATE")) {
                    let redCols = [];
                    if (tab === "PARTIAL_MATCH_INVOICE") redCols = ["Invoice_Date_Books", "Invoice_Date_Portal"];
                    if (tab === "PARTIAL_MATCH_DATE") redCols = ["Invoice_No_Books", "Invoice_No_Portal"];
                    if (tab === "MISMATCH" || tab === "MISMATCH_DATE") redCols = cols.filter(cn => /^Difference_/.test(cn) || /Invoice_No_Books|Invoice_Date_Books|Invoice_No_Portal|Invoice_Date_Portal/.test(cn));
                    let head = cols[colNumber - 1];
                    if (redCols.includes(head)) {
                        cell.font = { ...cell.font, color: { argb: "FFD0001C" }, bold: true }
                    }
                }
            });
        }

        // Totals row
        if (cols.some(c => totalCols.includes(c))) {
            sheet.addRow([]);
            let totalArr = [];
            for (let ix = 0; ix < cols.length; ix++) {
                let c = cols[ix];
                let headerName = displayHeaders[ix];
                if (totalCols.includes(c)) {
                    let val = totals[c] || 0;
                    totalArr.push(val);
                } else {
                    totalArr.push("");
                }
            }
            let totalHeaderRow = sheet.addRow([]);
            totalHeaderRow.height = 18;
            totalHeaderRow.getCell(1).value = "Totals:";
            totalHeaderRow.getCell(1).font = { bold: true, color: { argb: "FF0a6ebd" }, name: "Bookman Old Style" };
            totalHeaderRow.getCell(1).fill = { type: "pattern", pattern: "solid", fgColor: { argb: "FFF9F9BE" } };
            totalHeaderRow.getCell(1).alignment = { vertical: "middle", horizontal: "left", wrapText: true };
            sheet.mergeCells(totalHeaderRow.number, 1, totalHeaderRow.number, cols.length);
            let totalRow = sheet.addRow(totalArr);
            totalRow.height = 18;
            totalRow.eachCell((cell, colNumber) => {
                let colName = displayHeaders[colNumber - 1];
                if (typeof totalArr[colNumber - 1] === "number" && indianNumberCols.includes(colName)) {
                    cell.numFmt = getIndianNumFmt();
                    cell.alignment = { vertical: "middle", horizontal: "right", wrapText: false };
                } else if (/(Date)/i.test(colName)) {
                    cell.alignment = { vertical: "middle", horizontal: "right", wrapText: false };
                } else {
                    cell.alignment = { vertical: "middle", horizontal: "left", wrapText: false };
                }
                cell.font = { name: "Bookman Old Style", bold: true, color: { argb: "FF0a6ebd" } };
                cell.border = { top: { style: "thin" }, left: { style: "thin" }, right: { style: "thin" }, bottom: { style: "thin" } };
            });
        }

        // Apply fixed column widths
        displayHeaders.forEach((header, i) => {
            let mapped = header.trim();
            if (fixedWidths.hasOwnProperty(mapped)) {
                sheet.getColumn(i + 1).width = fixedWidths[mapped];
            } else {
                sheet.getColumn(i + 1).width = 12; // Default width for others
            }
        });

        // Set minimum row height for every row (including headers etc.)
        sheet.eachRow((row, rowNumber) => {
            if (rowNumber === headerRow.number) {
                if (!row.height || row.height < 36) row.height = 36;
            } else {
                if (!row.height || row.height < 18) row.height = 18;
            }
        });
    }
    // Export to file
    const buf = await workbook.xlsx.writeBuffer();
    saveAs(new Blob([buf]), "GST_Reconciliation_Output.xlsx");
}
// ... [The rest of your reconciliation logic, rendering, etc. stays the same] ...
</script>
</body>
</html>